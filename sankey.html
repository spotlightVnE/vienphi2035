<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <title>Tài chính y tế Việt Nam</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Playfair+Display:wght@400;700&display=swap" rel="stylesheet">

  <!-- D3.js and D3-Sankey -->
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/d3-sankey@0.12.3/dist/d3-sankey.min.js"></script>

  <style>
    :root {
      --primary-bg: #0F172A;
      --secondary-bg: #1E293B;
      --accent-blue: #3B82F6;
      --accent-purple: #8B5CF6;
      --accent-emerald: #10B981;
      --accent-gold: #F59E0B;
      --text-primary: #F8FAFC;
      --text-secondary: #CBD5E1;
      --text-muted: #64748B;
      --border: #334155;
      --card-bg: #1E293B;
      --glass-bg: rgba(30, 41, 59, 0.8);
      --tooltip-bg: rgba(15, 23, 42, 0.95);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 0;
      background: linear-gradient(135deg, var(--primary-bg) 0%, #1E293B 100%);
      font-family: "Inter", -apple-system, BlinkMacSystemFont, sans-serif;
      color: var(--text-primary);
      min-height: 100vh;
      overflow-x: hidden;
    }

    /* Animated background particles */
    .bg-particles {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: -1;
    }

    .particle {
      position: absolute;
      width: 2px;
      height: 2px;
      background: var(--accent-blue);
      border-radius: 50%;
      opacity: 0.3;
      animation: float 6s ease-in-out infinite;
    }

    @keyframes float {
      0%, 100% { transform: translateY(0px) rotate(0deg); opacity: 0.3; }
      50% { transform: translateY(-20px) rotate(180deg); opacity: 0.6; }
    }

    /* Header */
    .header {
      text-align: center;
      padding: 40px 20px 30px 20px;
      background: var(--glass-bg);
      backdrop-filter: blur(15px);
      border-bottom: 1px solid var(--border);
      position: relative;
    }

    .header::before {
      content: '';
      position: absolute;
      top: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 200px;
      height: 2px;
      background: linear-gradient(90deg, transparent, var(--accent-blue), transparent);
    }

    .title {
      font-family: "Playfair Display", serif;
      font-size: clamp(24px, 4vw, 36px);
      font-weight: 700;
      margin: 0 0 10px 0;
      background: linear-gradient(135deg, var(--text-primary), var(--accent-blue));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .subtitle {
      font-size: 16px;
      color: var(--text-secondary);
      margin: 0;
      max-width: 800px;
      margin-left: auto;
      margin-right: auto;
      line-height: 1.5;
    }


    /* Main container */
    .main-container {
      padding: 20px;
      max-width: 1400px;
      margin: 0 auto;
    }

    /* Sankey container */
    .sankey-container {
      background: var(--card-bg);
      border-radius: 16px;
      border: 1px solid var(--border);
      padding: 30px; /* Default padding */
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      position: relative;
      overflow: hidden;
    }

    .chart-wrapper {
      width: 100%;
      max-width: 1400px; /* Max width of the chart itself */
      margin: 0 auto;
      overflow: hidden; /* Clip overflow and remove horizontal scroll bar */
      border-radius: 8px;
    }

    svg {
      display: block;
      /* width and height will be set by D3 */
      background: linear-gradient(135deg, #1E293B 0%, #334155 100%);
    }

    /* Sankey elements */
    .link {
      fill: none;
      stroke-opacity: 0.4;
      transition: all 0.3s ease;
      filter: drop-shadow(0 0 2px rgba(0,0,0,0.3));
    }

    .link:hover {
      stroke-opacity: 0.8;
      filter: drop-shadow(0 0 6px rgba(59, 130, 246, 0.6));
    }

    .link.highlighted {
      stroke-opacity: 0.9;
      filter: drop-shadow(0 0 8px rgba(59, 130, 246, 0.8));
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0%, 100% { stroke-opacity: 0.9; }
      50% { stroke-opacity: 0.6; }
    }

    .node rect {
      stroke: var(--border);
      stroke-width: 1px;
      rx: 6;
      ry: 6;
      transition: all 0.3s ease;
      filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
    }

    .node:hover rect {
      stroke-width: 2px;
      stroke: var(--accent-blue);
      filter: drop-shadow(0 4px 12px rgba(59, 130, 246, 0.4));
      transform: scale(1.02); /* Keep or remove based on preference */
    }

    .node text {
      /* Font size set dynamically in JS */
      font-weight: 600; /* Base weight, can be adjusted in JS */
      pointer-events: none;
      text-anchor: auto; /* Set dynamically in JS */
      font-family: "Inter", sans-serif;
      fill: var(--text-primary); /* Base color, can be adjusted in JS */
      text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
    }

    /* Enhanced Tooltip */
    .tooltip {
      position: absolute;
      background: #23293a;
      border: none;
      border-radius: 0; /* Changed from 8px */
      padding: 14px 18px;
      font-size: 14px;
      color: #fff;
      pointer-events: none;
      opacity: 0;
      transform: translate(-50%, -100%);
      box-shadow: 0 2px 10px rgba(0,0,0,0.4);
      transition: opacity 0.25s, transform 0.25s;
      z-index: 1000;
      min-width: 160px;
      max-width: 350px;
    }
    .tooltip.show {
      opacity: 1;
      transform: translate(-50%, calc(-100% - 10px));
    }

    /* Help icon and popover */
    .help {
      position: relative;
      display: inline-block;
      cursor: help;
      margin-left: 4px;
    }
    .help-text {
      visibility: hidden;
      opacity: 0;
      width: 220px;
      background-color: var(--card-bg);
      color: var(--text-primary);
      text-align: left;
      border-radius: 8px;
      padding: 8px;
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      z-index: 1001;
      border: 1px solid var(--border);
      box-shadow: 0 4px 12px rgba(0,0,0,0.5);
      transition: opacity 0.2s ease, visibility 0.2s;
      font-size: 12px;
      line-height: 1.4;
    }
    .help:hover .help-text {
      visibility: visible;
      opacity: 1;
    }

    /* Stats panel */
    .stats-panel {
      margin-top: 30px;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 20px;
    }

    .stat-card {
      background: var(--glass-bg);
      backdrop-filter: blur(10px);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 20px;
      text-align: center;
      transition: transform 0.3s ease;
    }

    .stat-card:hover {
      transform: translateY(-4px);
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
    }

    .stat-value {
      font-size: 24px;
      font-weight: 700;
      color: var(--accent-blue);
      margin-bottom: 8px;
    }

    .stat-label {
      font-size: 14px;
      color: var(--text-secondary);
    }

    /* Responsive */
    .che-underline {
      text-decoration: underline;
      cursor: help;
    }
    @media (max-width: 768px) {
      .header {
        padding: 20px 10px 20px 10px; /* Reduced padding */
      }
      .title {
        font-size: clamp(20px, 5vw, 28px); /* Slightly smaller title */
      }
      .subtitle {
        font-size: 14px; /* Slightly smaller subtitle */
      }
      
      
      .main-container {
        padding: 10px; /* Significantly reduced padding */
      }
      
      .sankey-container {
        padding: 5px; /* Significantly reduced padding */
        border-radius: 8px; /* Slightly smaller border radius */
      }

      .chart-wrapper {
        border-radius: 6px; /* Match inner container */
      }

      .tooltip {
        max-width: 200px; /* Adjust tooltip size for mobile */
        min-width: 140px;
        padding: 10px 12px; /* Smaller tooltip padding */
        font-size: 12px;
      }
      .tooltip-title { /* Assuming you might add classes like this in JS for tooltip content */
        font-size: 13px;
      }
      .tooltip-value {
        font-size: 15px;
      }

      .stats-panel {
        margin-top: 20px;
        gap: 10px;
      }
      .stat-card {
        padding: 15px;
      }
      .stat-value {
        font-size: 20px;
      }
      .stat-label {
        font-size: 12px;
      }

      /* Hide step-2 labels on mobile */
      text.step2 {
        opacity: 0;
        transition: opacity 0.2s ease;
      }
      text.step2.active {
        opacity: 1;
      }
    }
  </style>
</head>

<body>
  <!-- Animated background -->
  <div class="bg-particles" id="particles"></div>

  <!-- Main Container -->
  <div class="main-container">
    <h2 style="text-align:center; font-size: 1.2rem; font-weight: 600; margin: 20px auto 15px auto; color: #F8FAFC;">
      Trong năm 2022, Việt Nam đã chi <span id="che-amount" class="che-underline">438,2 nghìn tỷ</span> cho y tế.
    </h2>
    <!-- Sankey Chart -->
    <div class="sankey-container">
      <div class="chart-wrapper">
        <svg id="sankey"></svg>
      </div>
    </div>
    <div style="margin: 20px auto 10px auto; max-width: 800px; color: #94a3b8; font-size: 11px; text-align: center; line-height: 1.4;">
      <b>Phương pháp:</b> Dữ liệu dòng tài chính y tế dựa trên Hệ thống Tài khoản Y tế (SHA 2011), phân loại các nguồn chi, phương thức và điểm đến cuối cùng của chi tiêu.<br>
      <b>Nguồn:</b> Bộ Y tế Việt Nam (2024), Báo cáo Tổng hợp Tài chính Y tế năm 2022, mã SHA 2011.
    </div>
  </div>

  <!-- Enhanced Tooltip -->
  <div class="tooltip" id="tooltip"></div>
  
  <!-- Placeholder for stats if you add them later -->
  <!-- 
  <div class="stats-panel main-container">
      <div class="stat-card">
          <div class="stat-value" id="total-value">-</div>
          <div class="stat-label">Tổng Chi Tiêu (nghìn tỷ VNĐ)</div>
      </div>
      <div class="stat-card">
          <div class="stat-value" id="node-count">-</div>
          <div class="stat-label">Số Lượng Nút</div>
      </div>
      <div class="stat-card">
          <div class="stat-value" id="flow-count">-</div>
          <div class="stat-label">Số Luồng Chính</div>
      </div>
  </div>
  -->

  <script>
  (function() {
    // Track toggled node for mobile tap-to-toggle
    let activeToggledNodeId = null;
    // Create animated background
    function createParticles() {
      const container = document.getElementById('particles');
      if (!container) return; // Ensure container exists
      for (let i = 0; i < 50; i++) {
        const particle = document.createElement('div');
        particle.className = 'particle';
        particle.style.left = Math.random() * 100 + '%';
        particle.style.top = Math.random() * 100 + '%';
        particle.style.animationDelay = Math.random() * 6 + 's';
        particle.style.animationDuration = (Math.random() * 4 + 4) + 's';
        container.appendChild(particle);
      }
    }
    createParticles();

    // Data
    const sankeyDataCSV = `
Nguồn|Đích|Giá trị|Bước Nguồn|Bước Đích
Tiền từ ngân sách chính phủ|Tiền viện trợ trong nước|78698596|1|2
Tiền viện trợ trong nước|Ngân sách và bảo hiểm y tế bắt buộc|78698596|2|3
Tiền từ ngân sách chính phủ|Tiền hỗ trợ từ chính phủ cho nhóm cụ thể (ví dụ: người nghèo, trẻ em, người già)|46374849|1|2
Tiền hỗ trợ từ chính phủ cho nhóm cụ thể (ví dụ: người nghèo, trẻ em, người già)|Ngân sách và bảo hiểm y tế bắt buộc|46374849|2|3
Tiền từ nước ngoài (viện trợ quốc tế)|Chương trình sức khỏe công cộng|4056060|1|2
Chương trình sức khỏe công cộng|Ngân sách và bảo hiểm y tế bắt buộc|4056060|2|3
Tiền do hộ gia đình và người lao động đóng góp|Tiền bảo hiểm do người lao động đóng|14911948|1|2
Tiền bảo hiểm do người lao động đóng|Ngân sách và bảo hiểm y tế bắt buộc|14911948|2|3
Tiền do doanh nghiệp đóng góp|Tiền bảo hiểm do doanh nghiệp đóng|29823898|1|2
Tiền bảo hiểm do doanh nghiệp đóng|Ngân sách và bảo hiểm y tế bắt buộc|29823898|2|3
Các nguồn khác|Các loại đóng góp bảo hiểm khác|21343672|1|2
Các loại đóng góp bảo hiểm khác|Ngân sách và bảo hiểm y tế bắt buộc|21343672|2|3
Các nguồn khác|Tiền trả trước tự nguyện (ví dụ: bảo hiểm sức khỏe tự nguyện)|24075000|1|2
Tiền trả trước tự nguyện (ví dụ: bảo hiểm sức khỏe tự nguyện)|Chương trình sức khỏe tự nguyện|24075000|2|3
Tiền do hộ gia đình và người lao động đóng góp|Chi trả trực tiếp khi khám chữa bệnh|173280507|1|2
Chi trả trực tiếp khi khám chữa bệnh|Chi phí tự trả khi khám chữa bệnh (OOP)|173280507|2|3
Tiền do doanh nghiệp đóng góp|Các khoản chi khác từ doanh nghiệp|31936196|1|2
Các khoản chi khác từ doanh nghiệp|Chương trình sức khỏe tự nguyện|31936196|2|3
Tiền từ các tổ chức phi lợi nhuận|Các khoản chi khác từ tổ chức phi lợi nhuận|10792656|1|2
Các khoản chi khác từ tổ chức phi lợi nhuận|Chương trình sức khỏe tự nguyện|10792656|2|3
Tiền từ nước ngoài (viện trợ quốc tế)|Viện trợ ngân sách từ nước ngoài|2890171|1|2
Viện trợ ngân sách từ nước ngoài|Chương trình sức khỏe tự nguyện|2890171|2|3`.trim();

    const parsedLinks = d3.dsvFormat("|").parse(sankeyDataCSV, d => ({
      source: d['Nguồn'],
      target: d['Đích'],
      value: +d['Giá trị'],
      step_from: +d['Bước Nguồn'],
      step_to: +d['Bước Đích']
    }));

    const filteredLinks = parsedLinks.filter(l => l.value > 0);

    const nodeSet = new Set();
    filteredLinks.forEach(l => { nodeSet.add(l.source); nodeSet.add(l.target); });
    const nodes = Array.from(nodeSet).map(id => ({ id }));

    nodes.forEach(n => {
      let stepVal = Infinity;
      filteredLinks.forEach(l => {
        if (l.source === n.id) stepVal = Math.min(stepVal, l.step_from);
        if (l.target === n.id) stepVal = Math.min(stepVal, l.step_to);
      });
      n.step = stepVal === Infinity ? 1 : stepVal;
    });

    const grandTotal = filteredLinks.reduce((sum, link) => sum + link.value, 0) / 2;

    const extraInfo = {
      'Tiền từ ngân sách chính phủ': 'Các nguồn chi từ ngân sách nhà nước trung ương và địa phương.',
      'Tiền viện trợ trong nước': 'Nguồn tài trợ từ các chương trình, quỹ và tổ chức trong nước.',
      'Tiền hỗ trợ từ chính phủ cho nhóm cụ thể (ví dụ: người nghèo, trẻ em, người già)': 'Ngân sách hỗ trợ đóng BHYT cho các nhóm ưu tiên theo quy định.',
      'Tiền từ nước ngoài (viện trợ quốc tế)': 'Viện trợ ODA và hỗ trợ kỹ thuật từ các chính phủ và tổ chức quốc tế.',
      'Tiền bảo hiểm do người lao động đóng': 'Phần bảo hiểm y tế bắt buộc do người lao động trích lương đóng.',
      'Tiền bảo hiểm do doanh nghiệp đóng': 'Phần bảo hiểm y tế bắt buộc do doanh nghiệp đóng góp cho người lao động.',
      'Các loại đóng góp bảo hiểm khác': 'Đóng góp BHYT tự nguyện và các hình thức bảo hiểm bổ sung khác.',
      'Tiền trả trước tự nguyện (ví dụ: bảo hiểm sức khỏe tự nguyện)': 'Mua bảo hiểm y tế thương mại và các quỹ trả trước tư nhân.',
      'Chi trả trực tiếp khi khám chữa bệnh': 'Chi phí túi tiền của hộ gia đình cho dịch vụ và thuốc tại cơ sở y tế (OOP).',
      'Chi phí tự trả khi khám chữa bệnh (OOP)': 'Tổng chi trực tiếp mà hộ gia đình tự chịu khi khám chữa bệnh.',
      'Các khoản chi khác từ doanh nghiệp': 'Hỗ trợ y tế, CSR và phúc lợi do doanh nghiệp tài trợ.',
      'Các khoản chi khác từ tổ chức phi lợi nhuận': 'Nguồn tài trợ y tế từ các tổ chức phi chính phủ và quỹ từ thiện.',
      'Viện trợ ngân sách từ nước ngoài': 'Viện trợ trực tiếp vào ngân sách nhà nước từ nguồn nước ngoài.',
      'Chương trình sức khỏe công cộng': 'Các dự án và chương trình y tế công do chính phủ hoặc tổ chức triển khai.',
    };

    const sourcePalette = ['#FF6B6B', '#FDB45C', '#3B82F6', '#1DD2AF', '#8E44AD', '#E67E22', '#00A8FF', '#9C88FF'];
    let srcIdx = 0;
    nodes.forEach(n => {
      if (n.step === 1) {
        n.color = sourcePalette[srcIdx % sourcePalette.length];
        srcIdx += 1;
      }
    });
    nodes.forEach(n => {
      if (n.step !== 1) {
        const incoming = filteredLinks.filter(l => l.target === n.id);
        if (incoming.length) {
          const dominant = incoming.reduce((a, b) => (a.value > b.value ? a : b));
          const originNode = nodes.find(x => x.id === dominant.source);
          n.color = originNode?.color || '#444444';
        }
      }
    });

    const graph = { nodes, links: filteredLinks };
    const svg = d3.select("#sankey");
    const tooltip = d3.select("#tooltip");
    let columnTotals = {};

    const MOBILE_BREAKPOINT = 768; // Align with CSS media query

    // Sankey generator configuration will be adjusted in updateChart
    const sankeyGen = d3.sankey()
      .nodeId(d => d.id)
      .nodeAlign(d3.sankeyJustify)
      // .nodeWidth, .nodePadding, .extent will be set inside updateChart()
      .nodeSort((a, b) => {
        const originOrder = [
          'Tiền do hộ gia đình và người lao động đóng góp', 'Tiền từ ngân sách chính phủ', 'Tiền do doanh nghiệp đóng góp',
          'Các nguồn khác', 'Tiền từ các tổ chức phi lợi nhuận', 'Tiền từ nước ngoài (viện trợ quốc tế)'
        ];
        const destOrder = [
          'Chi phí tự trả khi khám chữa bệnh (OOP)', 'Ngân sách và bảo hiểm y tế bắt buộc', 'Chương trình sức khỏe tự nguyện'
        ];
        const methodOrder = [
          'Chi trả trực tiếp khi khám chữa bệnh', 'Tiền bảo hiểm do người lao động đóng', 'Tiền viện trợ trong nước',
          'Tiền hỗ trợ từ chính phủ cho nhóm cụ thể (ví dụ: người nghèo, trẻ em, người già)', 'Tiền bảo hiểm do doanh nghiệp đóng',
          'Các khoản chi khác từ doanh nghiệp', 'Các loại đóng góp bảo hiểm khác', 'Tiền trả trước tự nguyện (ví dụ: bảo hiểm sức khỏe tự nguyện)',
          'Các khoản chi khác từ tổ chức phi lợi nhuận', 'Chương trình sức khỏe công cộng', 'Viện trợ ngân sách từ nước ngoài'
        ];
        if (a.x0 !== b.x0) return 0;
        const rankOrigin = n => { const idx = originOrder.indexOf(n.id); return idx === -1 ? originOrder.length : idx; };
        const rankDest = n => { const idx = destOrder.indexOf(n.id); return idx === -1 ? destOrder.length : idx; };
        if (a.step === 1) return d3.ascending(rankOrigin(a), rankOrigin(b));
        if (a.step === 3) return d3.ascending(rankDest(a), rankDest(b));
        if (a.step === 2) {
          const ra = methodOrder.indexOf(a.id); const rb = methodOrder.indexOf(b.id);
          return d3.ascending(ra === -1 ? methodOrder.length : ra, rb === -1 ? methodOrder.length : rb);
        }
        return 0;
      });
      
    function getChartSize() {
      const chartWrapperEl = document.querySelector('.chart-wrapper');
      const containerWidth = chartWrapperEl ? chartWrapperEl.clientWidth : window.innerWidth;
      return { width: Math.max(window.innerWidth <= MOBILE_BREAKPOINT ? 300 : 360, containerWidth) };
    }

    window.addEventListener("resize", updateChart);

    function updateChart() {
      // Compute dynamic height to fill below header and title
      const headerEl = document.querySelector('.header');
      const titleEl = document.querySelector('.main-container h2');
      const footnoteEl = document.querySelector('.main-container > div[style*="font-size"]');
      const headerH = headerEl ? headerEl.getBoundingClientRect().height : 0;
      const titleH = titleEl ? titleEl.getBoundingClientRect().height : 0;
      const footnoteH = footnoteEl ? footnoteEl.getBoundingClientRect().height : 0;
      const totalMargin = 80; // reduced to allow more chart height
      const height = Math.max(200, window.innerHeight - headerH - titleH - footnoteH - totalMargin);
      const { width } = getChartSize();
      svg.attr("width", width).attr("height", height);

      const isMobile = window.innerWidth <= MOBILE_BREAKPOINT;

      // Adjust Sankey parameters for mobile
      const nodeWidth = isMobile ? 10 : 16;
      const nodePadding = isMobile ? 16 : 16;
      const sankeyHorizontalPadding = isMobile ? 5 : Math.max(40, width * 0.05); // Reduced hPad for mobile
      const sankeyVerticalPadding = isMobile ? 10 : 40; // Reduced vertical padding for mobile

      sankeyGen
        .nodeWidth(nodeWidth)
        .nodePadding(nodePadding)
        .extent([[sankeyHorizontalPadding, sankeyVerticalPadding], [width - sankeyHorizontalPadding, height - sankeyVerticalPadding]]);
      
      const { nodes: sankeyNodes, links: sankeyLinks } = sankeyGen(graph);

      columnTotals = {1:0, 2:0, 3:0};
      sankeyNodes.forEach(n => { columnTotals[n.step] = (columnTotals[n.step] || 0) + n.value; });

      svg.selectAll("*").remove();

      const nodeColorMap = new Map();
      sankeyNodes.forEach(node => nodeColorMap.set(node.id, node.color));

      const defs = svg.append("defs");
      sankeyLinks.forEach((link, i) => {
        const sourceColor = nodeColorMap.get(link.source.id);
        const targetColor = nodeColorMap.get(link.target.id);
        const gradient = defs.append("linearGradient")
          .attr("id", `gradient-${i}`)
          .attr("gradientUnits", "userSpaceOnUse")
          .attr("x1", link.source.x1).attr("y1", (link.source.y0 + link.source.y1) / 2)
          .attr("x2", link.target.x0).attr("y2", (link.target.y0 + link.target.y1) / 2);
        gradient.append("stop").attr("offset", "0%").attr("stop-color", sourceColor).attr("stop-opacity", 0.8);
        gradient.append("stop").attr("offset", "100%").attr("stop-color", targetColor).attr("stop-opacity", 0.8);
      });

      const linkGroup = svg.append("g").attr("class", "links");
      linkGroup.selectAll("path")
        .data(sankeyLinks).enter().append("path")
        .attr("class", "link")
        .attr("d", d3.sankeyLinkHorizontal())
        .attr("stroke", (d, i) => `url(#gradient-${i})`)
        .attr("stroke-width", d => Math.max(1, d.width))
        .on("mouseover", function(event, d) {
          d3.select(this).classed("highlighted", true);
          linkGroup.selectAll("path").style("stroke-opacity", l => l === d ? 0.9 : 0.05);
          nodeGroup.selectAll("rect").style("fill-opacity", n => (n.id === d.source.id || n.id === d.target.id) ? 1 : 0.2);
          nodeGroup.selectAll("text").style("fill-opacity", n => (n.id === d.source.id || n.id === d.target.id) ? 1 : 0.2);
          showLinkTooltip(event, d);
        })
        .on("mouseout", function() {
          d3.select(this).classed("highlighted", false);
          linkGroup.selectAll("path").style("stroke-opacity", 0.4);
          nodeGroup.selectAll("rect").style("fill-opacity", n => n.step === 2 ? 0.25 : 1);
          nodeGroup.selectAll("text").style("fill-opacity", 1);
          hideTooltip();
        });

      const nodeGroup = svg.append("g").attr("class", "nodes");
      const nodeSelection = nodeGroup.selectAll("g")
        .data(sankeyNodes).enter().append("g")
        .attr("class", "node")
        .attr("transform", d => `translate(${d.x0},${d.y0})`);

      nodeSelection.append("rect")
        .attr("width", d => d.x1 - d.x0)
        .attr("height", d => d.y1 - d.y0)
        .attr("rx", isMobile ? 4 : 6) // Smaller radius for mobile
        .attr("ry", isMobile ? 4 : 6)
        .attr("fill", d => d.color)
        .attr("fill-opacity", d => d.step === 2 ? 0.25 : 1)
        .attr("stroke", 'var(--border)')
        .attr("stroke-width", 1)
        .on("mouseover", function(event, d) {
          const relatedIds = new Set([d.id]);
          const firstHop = [];
          sankeyLinks.forEach(l => {
            if (l.source.id === d.id) { relatedIds.add(l.target.id); firstHop.push(l.target.id); }
            if (l.target.id === d.id) { relatedIds.add(l.source.id); firstHop.push(l.source.id); }
          });
          sankeyLinks.forEach(l => {
            if (firstHop.includes(l.source.id)) relatedIds.add(l.target.id);
            if (firstHop.includes(l.target.id)) relatedIds.add(l.source.id);
          });
          d3.select(this).attr("stroke-width", 2).attr("stroke", 'var(--accent-blue)');
          linkGroup.selectAll("path").style("stroke-opacity", l => (relatedIds.has(l.source.id) && relatedIds.has(l.target.id)) ? 0.9 : 0.05);
          nodeGroup.selectAll("rect").style("fill-opacity", n => relatedIds.has(n.id) ? 1 : (n.step === 2 ? 0.05 : 0.1));
          nodeGroup.selectAll("text").style("fill-opacity", n => relatedIds.has(n.id) ? 1 : 0.1);
          // --- Begin: step-2 label activation for mobile ---
          const isMobile = window.innerWidth <= MOBILE_BREAKPOINT;
          d3.selectAll('text.step2').classed('active', false);

          if (isMobile && (d.step === 1 || d.step === 3)) {
            // Find related step-2 node ids
            const relatedStep2Ids = new Set();
            sankeyLinks.forEach(l => {
              if (d.step === 1 && l.source.id === d.id && l.target.step === 2) relatedStep2Ids.add(l.target.id);
              if (d.step === 3 && l.target.id === d.id && l.source.step === 2) relatedStep2Ids.add(l.source.id);
            });
            // Activate only those
            d3.selectAll('g.node').each(function(n) {
              if (n.step === 2 && relatedStep2Ids.has(n.id)) {
                d3.select(this).selectAll('text.step2').classed('active', true);
              }
            });
          }
          // --- End: step-2 label activation for mobile ---
          showNodeTooltip(event, d);
        })
        .on("mouseout", function() {
          d3.select(this).attr("stroke-width", 1).attr("stroke", 'var(--border)');
          linkGroup.selectAll("path").style("stroke-opacity", 0.4);
          nodeGroup.selectAll("rect").style("fill-opacity", n => n.step === 2 ? 0.25 : 1);
          nodeGroup.selectAll("text").style("fill-opacity", 1);
          // --- Begin: step-2 label deactivation for mobile ---
          if (window.innerWidth <= MOBILE_BREAKPOINT) {
            d3.selectAll('text.step2').classed('active', false);
          }
          // --- End: step-2 label deactivation for mobile ---
          hideTooltip();
        });

      // Pointer/tap handlers for node tap-to-toggle on mobile
      nodeSelection
        .on("pointerdown", (event, d) => {
          const isMobile = window.innerWidth <= MOBILE_BREAKPOINT;
          if (isMobile && activeToggledNodeId === d.id) {
            // second tap on same node: hide
            activeToggledNodeId = null;
            highlightNode(event, d, false);
            hideTooltip();
          } else {
            // first tap or different node: show
            activeToggledNodeId = d.id;
            highlightNode(event, d, true);
            showNodeTooltip(event, d);
          }
        })
        .on("pointerleave", (event, d) => {
          const isMobile = window.innerWidth <= MOBILE_BREAKPOINT;
          if (!isMobile) {
            activeToggledNodeId = null;
            highlightNode(event, d, false);
            hideTooltip();
          }
        });

      // Helper for node highlight logic (for tap-to-toggle and pointer)
      function highlightNode(event, d, show) {
        const relatedIds = new Set([d.id]);
        const firstHop = [];
        sankeyLinks.forEach(l => {
          if (l.source.id === d.id) { relatedIds.add(l.target.id); firstHop.push(l.target.id); }
          if (l.target.id === d.id) { relatedIds.add(l.source.id); firstHop.push(l.source.id); }
        });
        sankeyLinks.forEach(l => {
          if (firstHop.includes(l.source.id)) relatedIds.add(l.target.id);
          if (firstHop.includes(l.target.id)) relatedIds.add(l.source.id);
        });
        nodeGroup.selectAll("rect")
          .style("fill-opacity", n => show ? (relatedIds.has(n.id) ? 1 : (n.step === 2 ? 0.05 : 0.1)) : (n.step === 2 ? 0.25 : 1));
        nodeGroup.selectAll("text")
          .style("fill-opacity", n => show ? (relatedIds.has(n.id) ? 1 : 0.1) : 1);
        linkGroup.selectAll("path")
          .style("stroke-opacity", l => show ? ((relatedIds.has(l.source.id) && relatedIds.has(l.target.id)) ? 0.9 : 0.05) : 0.4);
        nodeGroup.selectAll("rect")
          .attr("stroke-width", n => n.id === d.id && show ? 2 : 1)
          .attr("stroke", n => n.id === d.id && show ? 'var(--accent-blue)' : 'var(--border)');
        // step-2 label activation for mobile
        const isMobile = window.innerWidth <= MOBILE_BREAKPOINT;
        d3.selectAll('text.step2').classed('active', false);
        if (isMobile && (d.step === 1 || d.step === 3) && show) {
          // Find related step-2 node ids
          const relatedStep2Ids = new Set();
          sankeyLinks.forEach(l => {
            if (d.step === 1 && l.source.id === d.id && l.target.step === 2) relatedStep2Ids.add(l.target.id);
            if (d.step === 3 && l.target.id === d.id && l.source.step === 2) relatedStep2Ids.add(l.source.id);
          });
          // Activate only those
          d3.selectAll('g.node').each(function(n) {
            if (n.step === 2 && relatedStep2Ids.has(n.id)) {
              d3.select(this).selectAll('text.step2').classed('active', true);
            }
          });
        }
      }

      nodeSelection.each(function(d) {
        // Skip drawing step-2 labels on mobile
        if (window.innerWidth <= MOBILE_BREAKPOINT && d.step === 2) return;
        const node = d3.select(this);
        const currentRectWidth = d.x1 - d.x0; // This is the actual nodeWidth from sankeyGen
        const nodeHeight = d.y1 - d.y0;
        
        const labelPadding = isMobile ? 8 : 15; // Reduced LABEL_PAD for mobile
        
        let textX, textAnchor;

        if (d.step === 1) { // Labels to the right of Step 1 nodes
          textX = currentRectWidth + labelPadding;
          textAnchor = "start";
        } else if (d.step === 3) { // Labels to the left of Step 3 nodes
          textX = -labelPadding; // Relative to d.x0, so negative to be left
          textAnchor = "end";
        } else { // Step 2, labels inside node
          textX = currentRectWidth / 2;
          textAnchor = "middle";
        }
        
        const words = d.id.split(' ');
        // Cap all nodes at 4 words per line on mobile, 6 on desktop.
        const maxWordsPerLine = isMobile ? 4 : 6;
        const lines = [];
        for (let i = 0; i < words.length; i += maxWordsPerLine) {
          lines.push(words.slice(i, i + maxWordsPerLine).join(' '));
        }

        const baseFontSize = isMobile ? (d.step === 2 ? "8px" : "10px") : (d.step === 2 ? "9px" : "13px"); // Further refined mobile font sizes
        const lineDy = isMobile ? (d.step === 2 ? 9 : 10) : 14; // Adjusted line height

        lines.forEach((line, lineIndex) => {
          node.append("text")
            .classed("step2", d.step === 2)
            .attr("x", textX)
            .attr("y", nodeHeight/2 + (lineIndex - (lines.length -1)/2) * lineDy ) // Adjusted y for proper centering
            .attr("dy", d.step === 2 ? "0.35em" : (isMobile ? "0.3em" : "0.35em")) // Vertical alignment adjusted for smaller fonts
            .attr("text-anchor", textAnchor)
            .style("font-size", baseFontSize)
            .style("font-weight", d.step === 2 ? "400" : "600")
            .style("fill", d.step === 2 ? (isMobile ? "#B0B2B3" : "#C6C8C9") : "#F8FAFC")
            .style("text-shadow", "1px 1px 1px rgba(0,0,0,0.7)") // Slightly reduced shadow for smaller fonts
            .text(line);
        });
      });
      // updateStats(); // Call if you implement the stats panel
    }

    function formatCurrency(value) {
      return (value / 1e6).toFixed(1) + ' nghìn tỷ VNĐ';
    }

    function showLinkTooltip(event, d) {
      const isMobile = window.innerWidth <= MOBILE_BREAKPOINT;
      tooltip.html(`
        <div style="font-size: ${isMobile ? '13px' : '16px'};font-weight:600;color:#3B82F6;margin-bottom:6px;">
          ${d.source.id} → ${d.target.id}
        </div>
        <div style="font-size:${isMobile ? '18px' : '22px'};font-weight:700;color:#10B981;">
          ${formatCurrency(d.value)}
        </div>
        <div style="font-size:${isMobile ? '11px' : '13px'};color:#F59E0B;margin-top:3px;">
          ${(d.value / grandTotal * 100).toFixed(1)}%
        </div>
      `);
      // Position tooltip avoiding edge cut-off
      const tooltipNode = tooltip.node();
      const { width: tipW, height: tipH } = tooltipNode.getBoundingClientRect();
      const pageX = event.pageX;
      const pageY = event.pageY;
      const margin = 10;
      let leftPos = pageX, transformX = "-50%";
      let transformY = "-100%", topPos = pageY;
      // Right overflow
      if (pageX + tipW/2 > window.innerWidth - margin) {
        leftPos = window.innerWidth - tipW - margin;
        transformX = "0%";
      }
      // Left overflow
      else if (pageX - tipW/2 < margin) {
        leftPos = margin;
        transformX = "0%";
      }
      // Top overflow (tooltip would go above viewport)
      if (pageY - tipH < margin) {
        transformY = "0%";
        topPos = pageY + margin;
      }
      tooltip
        .style("left", leftPos + "px")
        .style("top", topPos + "px")
        .style("transform", `translate(${transformX}, ${transformY})`)
        .classed("show", true);
    }

    function showNodeTooltip(event, d) {
      const isMobile = window.innerWidth <= MOBILE_BREAKPOINT;
      const desc = extraInfo[d.id];
      const nodePercent = ((d.value / grandTotal) * 100).toFixed(1);
      tooltip.html(`
        <div style="font-size:${isMobile ? '13px' : '16px'};font-weight:600;color:#3B82F6;margin-bottom:6px;">
          ${d.id}
        </div>
        <div style="font-size:${isMobile ? '18px' : '22px'};font-weight:700;color:#10B981;">
          ${formatCurrency(d.value)}
        </div>
        <div style="font-size:${isMobile ? '11px' : '13px'};color:#F59E0B;margin-top:3px;">
          ${nodePercent}%
        </div>
        ${desc ? `<div style="font-size:${isMobile ? '10px' : '12px'};color:#CBD5E1;margin-top:8px;">${desc}</div>` : ''}
      `);
      // Position tooltip avoiding edge cut-off
      const tooltipNode = tooltip.node();
      const { width: tipW, height: tipH } = tooltipNode.getBoundingClientRect();
      const pageX = event.pageX;
      const pageY = event.pageY;
      const margin = 10;
      let leftPos = pageX, transformX = "-50%";
      let transformY = "-100%", topPos = pageY;
      // Right overflow
      if (pageX + tipW/2 > window.innerWidth - margin) {
        leftPos = window.innerWidth - tipW - margin;
        transformX = "0%";
      }
      // Left overflow
      else if (pageX - tipW/2 < margin) {
        leftPos = margin;
        transformX = "0%";
      }
      // Top overflow (tooltip would go above viewport)
      if (pageY - tipH < margin) {
        transformY = "0%";
        topPos = pageY + margin;
      }
      tooltip
        .style("left", leftPos + "px")
        .style("top", topPos + "px")
        .style("transform", `translate(${transformX}, ${transformY})`)
        .classed("show", true);
    }

    function hideTooltip() {
      tooltip.classed("show", false);
    }

    // function updateStats() { // Example, if you add the HTML for these IDs
    //   const sumOfLinks = grandTotal;
    //   const totalBillion = (sumOfLinks / 1e6).toFixed(1);
    //   if(document.getElementById('total-value')) document.getElementById('total-value').textContent = totalBillion;
    //   if(document.getElementById('node-count')) document.getElementById('node-count').textContent = graph.nodes.length;
    //   if(document.getElementById('flow-count')) document.getElementById('flow-count').textContent = graph.links.length;
    // }

    // CHE comparison tooltip
    const cheElem = document.getElementById('che-amount');
    const cheTooltipContent = `
      <div style="font-size:14px; color:#F8FAFC;">
        Tương đương <b>4.59%</b> GDP, và <b>24.53%</b> tổng chi ngân sách
      </div>`;
    cheElem.addEventListener('pointerenter', event => {
      tooltip.html(cheTooltipContent);
      const tooltipNode2 = tooltip.node();
      const { width: tipW2, height: tipH2 } = tooltipNode2.getBoundingClientRect();
      const rect = cheElem.getBoundingClientRect();
      const margin = 10;
      let left2 = rect.left + rect.width/2, top2 = rect.bottom + 8, transformY2 = "-100%";
      // If too close to top
      if (top2 - tipH2 < margin) {
        transformY2 = "0%";
        top2 = rect.bottom + margin;
      }
      // Horizontal overflow
      if (left2 + tipW2/2 > window.innerWidth - margin) left2 = window.innerWidth - tipW2 - margin;
      else if (left2 - tipW2/2 < margin) left2 = margin;
      tooltip
        .style("left", left2 + "px")
        .style("top", top2 + "px")
        .style("transform", `translate(-50%, ${transformY2})`)
        .classed("show", true);
    });
    cheElem.addEventListener('pointerleave', () => {
      tooltip.classed("show", false);
    });

    // Hide tooltip on mobile when tapping outside a node
    document.addEventListener('pointerdown', (e) => {
      if (window.innerWidth <= MOBILE_BREAKPOINT && activeToggledNodeId) {
        // if click is not on a node or tooltip
        if (!e.target.closest('.node') && !e.target.closest('#tooltip') && e.target.id !== 'che-amount') {
          activeToggledNodeId = null;
          hideTooltip();
          // Clear any highlights
          nodeGroup && nodeGroup.selectAll('rect').style('fill-opacity', n => n.step===2?0.25:1)
                                        .attr('stroke-width',1).attr('stroke','var(--border)');
          linkGroup && linkGroup.selectAll('path').style('stroke-opacity',0.4);
          // Remove active class from step2 labels
          d3.selectAll('text.step2').classed('active', false);
        }
      }
    });

    updateChart(); // Initial chart rendering
  })();
  </script>
</body>
</html>
